#!/usr/bin/env python3
"""
Claude Code Integration System - Next Level Context Evolution
Automatically captures, analyzes, and integrates Claude Code conversations
"""

import os
import json
import time
import hashlib
import psutil
import sqlite3
from datetime import datetime, timedelta
from pathlib import Path
from typing import List, Dict, Any, Optional, Tuple
import re
import subprocess
from dataclasses import dataclass, asdict
from collections import defaultdict
import threading
import queue
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

@dataclass
class ClaudeConversation:
    """Represents a Claude Code conversation exchange"""
    timestamp: str
    user_input: str
    claude_response: str
    conversation_id: str
    session_id: str
    tools_used: List[str]
    files_mentioned: List[str]
    code_generated: bool
    insights_extracted: List[str]
    decisions_made: List[str]
    next_actions: List[str]
    conversation_type: str  # "question", "implementation", "debugging", "planning"
    importance_score: float
    context_impact: str  # "low", "medium", "high", "critical"

class ClaudeCodeMonitor(FileSystemEventHandler):
    """Monitors Claude Code activity and captures conversations"""
    
    def __init__(self, integration_system):
        self.integration_system = integration_system
        self.conversation_buffer = []
        self.last_activity = time.time()
        
    def on_modified(self, event):
        """Handle file modifications that might indicate Claude activity"""
        if event.is_directory:
            return
            
        # Monitor for Claude-generated files
        if self.is_claude_generated_file(event.src_path):
            self.integration_system.process_claude_file_change(event.src_path)
    
    def is_claude_generated_file(self, file_path: str) -> bool:
        """Check if file was likely generated by Claude"""
        # Look for Claude signatures in file content
        try:
            with open(file_path, 'r') as f:
                content = f.read()
                return any(marker in content for marker in [
                    "# region imports",
                    "from AlgorithmImports import *",
                    "class.*Test.*Algorithm",
                    "def Execute.*Analysis",
                    "SAKB Integration"
                ])
        except:
            return False

class ClaudeCodeIntegrationSystem:
    """
    Next-level context evolution system that integrates with Claude Code
    """
    
    def __init__(self, project_root: str = None):
        """Initialize Claude Code integration system"""
        self.project_root = Path(project_root) if project_root else Path.cwd()
        
        # Core integration files
        self.claude_conversations_db = self.project_root / "claude_capture" / "data" / "claude_conversations.db"
        self.claude_session_log = self.project_root / "claude_session_log.json"
        self.claude_insights_db = self.project_root / "claude_insights.db"
        
        # Integration directories
        self.claude_sessions_dir = self.project_root / "claude_sessions"
        self.claude_analysis_dir = self.project_root / "claude_analysis"
        self.claude_code_dir = self.project_root / "claude_generated_code"
        
        # Create directories
        for dir_path in [self.claude_sessions_dir, self.claude_analysis_dir, self.claude_code_dir]:
            dir_path.mkdir(exist_ok=True)
        
        # Initialize databases
        self.init_databases()
        
        # Load existing session data
        self.session_data = self.load_session_data()
        
        # Current session tracking
        self.current_session_id = self.generate_session_id()
        self.conversation_queue = queue.Queue()
        self.is_monitoring = False
        
        # File system monitor
        self.file_monitor = ClaudeCodeMonitor(self)
        
        # Integration with existing evolution system
        try:
            from context_evolution_system import ContextEvolutionSystem
            self.evolution_system = ContextEvolutionSystem(project_root)
        except ImportError:
            self.evolution_system = None
            print("âš ï¸  Context Evolution System not found, running in standalone mode")
        
        print(f"ðŸ¤– Claude Code Integration System initialized")
        print(f"ðŸ’¾ Database: {self.claude_conversations_db}")
        print(f"ðŸ“Š Session: {self.current_session_id}")
    
    def init_databases(self):
        """Initialize SQLite databases for conversation storage"""
        
        # Conversations database
        conn = sqlite3.connect(self.claude_conversations_db)
        cursor = conn.cursor()
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS conversations (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp TEXT,
                user_input TEXT,
                claude_response TEXT,
                conversation_id TEXT,
                session_id TEXT,
                tools_used TEXT,
                files_mentioned TEXT,
                code_generated INTEGER,
                insights_extracted TEXT,
                decisions_made TEXT,
                next_actions TEXT,
                conversation_type TEXT,
                importance_score REAL,
                context_impact TEXT,
                processed INTEGER DEFAULT 0
            )
        ''')
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS sessions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                session_id TEXT UNIQUE,
                start_time TEXT,
                end_time TEXT,
                purpose TEXT,
                total_conversations INTEGER,
                total_insights INTEGER,
                key_achievements TEXT,
                status TEXT
            )
        ''')
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS file_changes (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp TEXT,
                file_path TEXT,
                change_type TEXT,
                conversation_id TEXT,
                session_id TEXT,
                impact_level TEXT
            )
        ''')
        
        conn.commit()
        conn.close()
        
        print("ðŸ’¾ Claude Code databases initialized")
    
    def generate_session_id(self) -> str:
        """Generate unique session ID"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        return f"claude_session_{timestamp}"
    
    def load_session_data(self) -> Dict[str, Any]:
        """Load session data"""
        if self.claude_session_log.exists():
            with open(self.claude_session_log, 'r') as f:
                return json.load(f)
        return {
            "sessions": [],
            "current_session": None,
            "total_conversations": 0,
            "integration_version": "2.0"
        }
    
    def save_session_data(self):
        """Save session data"""
        with open(self.claude_session_log, 'w') as f:
            json.dump(self.session_data, f, indent=2, default=str)
    
    def start_claude_session(self, purpose: str = "Development session"):
        """Start a new Claude Code session"""
        
        session_info = {
            "session_id": self.current_session_id,
            "start_time": datetime.now().isoformat(),
            "purpose": purpose,
            "status": "active",
            "conversations": [],
            "insights": [],
            "files_changed": []
        }
        
        # Add to session data
        self.session_data["sessions"].append(session_info)
        self.session_data["current_session"] = self.current_session_id
        self.save_session_data()
        
        # Add to database
        conn = sqlite3.connect(self.claude_conversations_db)
        cursor = conn.cursor()
        cursor.execute('''
            INSERT INTO sessions (session_id, start_time, purpose, status)
            VALUES (?, ?, ?, ?)
        ''', (self.current_session_id, datetime.now().isoformat(), purpose, "active"))
        conn.commit()
        conn.close()
        
        # Start file monitoring
        self.start_file_monitoring()
        
        # Integrate with evolution system
        if self.evolution_system:
            self.evolution_system.start_session(f"Claude Code: {purpose}")
        
        print(f"ðŸš€ Claude Code session started: {self.current_session_id}")
        print(f"ðŸŽ¯ Purpose: {purpose}")
        print(f"ðŸ‘ï¸  File monitoring active")
        
        return self.current_session_id
    
    def capture_claude_conversation(self, 
                                  user_input: str,
                                  claude_response: str,
                                  tools_used: List[str] = None,
                                  auto_analyze: bool = True) -> ClaudeConversation:
        """Capture a Claude Code conversation"""
        
        conversation_id = hashlib.md5(f"{user_input}_{claude_response}_{time.time()}".encode()).hexdigest()[:12]
        
        # Analyze conversation
        if auto_analyze:
            analysis = self.analyze_claude_conversation(user_input, claude_response, tools_used or [])
        else:
            analysis = {
                "tools_used": tools_used or [],
                "files_mentioned": [],
                "code_generated": False,
                "insights_extracted": [],
                "decisions_made": [],
                "next_actions": [],
                "conversation_type": "general",
                "importance_score": 0.5,
                "context_impact": "medium"
            }
        
        # Create conversation object
        conversation = ClaudeConversation(
            timestamp=datetime.now().isoformat(),
            user_input=user_input,
            claude_response=claude_response,
            conversation_id=conversation_id,
            session_id=self.current_session_id,
            **analysis
        )
        
        # Store in database
        self.store_conversation(conversation)
        
        # Integrate with evolution system
        if self.evolution_system:
            for insight in conversation.insights_extracted:
                self.evolution_system.add_insight(insight, "claude_conversation", conversation.files_mentioned)
        
        print(f"ðŸ’¬ Captured Claude conversation: {conversation_id}")
        print(f"ðŸ“Š Insights: {len(conversation.insights_extracted)}, Tools: {len(conversation.tools_used)}")
        
        return conversation
    
    def analyze_claude_conversation(self, user_input: str, claude_response: str, tools_used: List[str]) -> Dict[str, Any]:
        """Analyze Claude conversation for insights and metadata"""
        
        combined_text = f"{user_input}\n{claude_response}"
        
        # Extract tools used
        tool_patterns = [
            r"<function_calls>.*?<invoke name=\"(\w+)\"",
            r"Called the (\w+) tool",
            r"Using (\w+) tool",
            r"I'll (\w+) the"
        ]
        
        extracted_tools = set(tools_used)
        for pattern in tool_patterns:
            matches = re.findall(pattern, combined_text, re.IGNORECASE | re.DOTALL)
            extracted_tools.update(matches)
        
        # Extract files mentioned
        file_patterns = [
            r"([a-zA-Z0-9_]+\.py)",
            r"([a-zA-Z0-9_]+\.md)",
            r"([a-zA-Z0-9_]+\.json)",
            r"([a-zA-Z0-9_]+\.sh)",
            r"test_\d+_[a-zA-Z0-9_]+\.py",
            r"/.*?/([a-zA-Z0-9_]+\.[a-zA-Z0-9]+)"
        ]
        
        files_mentioned = set()
        for pattern in file_patterns:
            matches = re.findall(pattern, combined_text)
            files_mentioned.update(matches)
        
        # Check for code generation
        code_indicators = [
            "```python",
            "```bash",
            "def ",
            "class ",
            "import ",
            "from ",
            "#!/usr/bin/env python3"
        ]
        
        code_generated = any(indicator in combined_text for indicator in code_indicators)
        
        # Extract insights
        insights = self.extract_conversation_insights(combined_text)
        
        # Extract decisions
        decisions = self.extract_decisions(combined_text)
        
        # Extract next actions
        next_actions = self.extract_next_actions(combined_text)
        
        # Determine conversation type
        conversation_type = self.classify_conversation_type(user_input, claude_response)
        
        # Calculate importance score
        importance_score = self.calculate_conversation_importance(user_input, claude_response, insights, tools_used)
        
        # Determine context impact
        context_impact = self.determine_context_impact(importance_score, tools_used, code_generated)
        
        return {
            "tools_used": list(extracted_tools),
            "files_mentioned": list(files_mentioned),
            "code_generated": code_generated,
            "insights_extracted": insights,
            "decisions_made": decisions,
            "next_actions": next_actions,
            "conversation_type": conversation_type,
            "importance_score": importance_score,
            "context_impact": context_impact
        }
    
    def extract_conversation_insights(self, text: str) -> List[str]:
        """Extract insights from conversation text"""
        insights = []
        
        # Enhanced insight patterns
        insight_patterns = [
            r"(?:Key|Important|Critical|Strategic)\s+(?:finding|insight|point|consideration)[:\s]+(.+?)(?:\n|$)",
            r"(?:This|That)\s+(?:means|suggests|indicates|implies)\s+(.+?)(?:\n|$)",
            r"(?:We|You)\s+(?:should|need to|must|will)\s+(.+?)(?:\n|$)",
            r"(?:The|A|An)\s+(?:main|primary|key|important)\s+(?:benefit|advantage|feature|insight)\s+(?:is|would be)\s+(.+?)(?:\n|$)",
            r"(?:Notice|Note|Observe)\s+(?:that|how)\s+(.+?)(?:\n|$)",
            r"(?:This|That)\s+(?:demonstrates|shows|proves|reveals)\s+(.+?)(?:\n|$)",
            r"(?:The|A|An)\s+(?:result|outcome|implication)\s+(?:is|will be)\s+(.+?)(?:\n|$)"
        ]
        
        for pattern in insight_patterns:
            matches = re.findall(pattern, text, re.IGNORECASE | re.MULTILINE)
            for match in matches:
                cleaned = match.strip().rstrip('.')
                if len(cleaned) > 15 and cleaned not in insights:
                    insights.append(cleaned)
        
        return insights[:10]  # Limit to top 10 insights
    
    def extract_decisions(self, text: str) -> List[str]:
        """Extract decisions made from conversation"""
        decisions = []
        
        decision_patterns = [
            r"(?:I'll|I will|Let's|We'll|We will|I'm going to)\s+(.+?)(?:\n|$)",
            r"(?:Decided|Decision|Choose|Selected|Picked)\s+(?:to|that)\s+(.+?)(?:\n|$)",
            r"(?:The|Our)\s+(?:approach|strategy|plan)\s+(?:is|will be)\s+(?:to\s+)?(.+?)(?:\n|$)"
        ]
        
        for pattern in decision_patterns:
            matches = re.findall(pattern, text, re.IGNORECASE | re.MULTILINE)
            for match in matches:
                cleaned = match.strip().rstrip('.')
                if len(cleaned) > 10 and cleaned not in decisions:
                    decisions.append(cleaned)
        
        return decisions[:5]  # Limit to top 5 decisions
    
    def extract_next_actions(self, text: str) -> List[str]:
        """Extract next actions from conversation"""
        actions = []
        
        action_patterns = [
            r"(?:Next|Now|Then)\s+(?:we|you|I)\s+(?:should|need to|will|can)\s+(.+?)(?:\n|$)",
            r"(?:The|Our)\s+(?:next|following)\s+(?:step|action|task)\s+(?:is|will be)\s+(?:to\s+)?(.+?)(?:\n|$)",
            r"(?:TODO|Action item|Next step)[:\s]+(.+?)(?:\n|$)",
            r"(?:You|We)\s+(?:could|might|should)\s+(?:also|now|then)\s+(.+?)(?:\n|$)"
        ]
        
        for pattern in action_patterns:
            matches = re.findall(pattern, text, re.IGNORECASE | re.MULTILINE)
            for match in matches:
                cleaned = match.strip().rstrip('.')
                if len(cleaned) > 10 and cleaned not in actions:
                    actions.append(cleaned)
        
        return actions[:5]  # Limit to top 5 actions
    
    def classify_conversation_type(self, user_input: str, claude_response: str) -> str:
        """Classify the type of conversation"""
        
        combined_text = f"{user_input}\n{claude_response}".lower()
        
        # Define classification patterns
        if any(word in combined_text for word in ["create", "build", "implement", "write", "develop", "make"]):
            return "implementation"
        elif any(word in combined_text for word in ["error", "bug", "fix", "debug", "issue", "problem"]):
            return "debugging"
        elif any(word in combined_text for word in ["plan", "strategy", "approach", "design", "architecture"]):
            return "planning"
        elif any(word in combined_text for word in ["explain", "how", "what", "why", "understand"]):
            return "question"
        elif any(word in combined_text for word in ["test", "validate", "verify", "check"]):
            return "testing"
        elif any(word in combined_text for word in ["optimize", "improve", "enhance", "better"]):
            return "optimization"
        else:
            return "general"
    
    def calculate_conversation_importance(self, user_input: str, claude_response: str, insights: List[str], tools_used: List[str]) -> float:
        """Calculate importance score for conversation"""
        
        score = 0.5  # Base score
        
        # High importance keywords
        high_importance_keywords = [
            "critical", "important", "key", "strategic", "breakthrough", "discovery",
            "test", "algorithm", "strategy", "sakb", "implementation", "production"
        ]
        
        medium_importance_keywords = [
            "insight", "finding", "recommendation", "approach", "method", "solution"
        ]
        
        combined_text = f"{user_input}\n{claude_response}".lower()
        
        # Keyword scoring
        for keyword in high_importance_keywords:
            if keyword in combined_text:
                score += 0.2
        
        for keyword in medium_importance_keywords:
            if keyword in combined_text:
                score += 0.1
        
        # Tool usage bonus
        if len(tools_used) > 0:
            score += 0.1 * len(tools_used)
        
        # Insights bonus
        if len(insights) > 0:
            score += 0.1 * len(insights)
        
        # Code generation bonus
        if any(indicator in combined_text for indicator in ["```python", "def ", "class ", "import "]):
            score += 0.2
        
        # Length bonus (longer conversations often more substantial)
        if len(combined_text) > 2000:
            score += 0.1
        
        return min(score, 1.0)
    
    def determine_context_impact(self, importance_score: float, tools_used: List[str], code_generated: bool) -> str:
        """Determine context impact level"""
        
        if importance_score > 0.8 or code_generated or len(tools_used) > 3:
            return "critical"
        elif importance_score > 0.6 or len(tools_used) > 1:
            return "high"
        elif importance_score > 0.4 or len(tools_used) > 0:
            return "medium"
        else:
            return "low"
    
    def store_conversation(self, conversation: ClaudeConversation):
        """Store conversation in database"""
        
        conn = sqlite3.connect(self.claude_conversations_db)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO conversations (
                timestamp, user_input, claude_response, conversation_id, session_id,
                tools_used, files_mentioned, code_generated, insights_extracted,
                decisions_made, next_actions, conversation_type, importance_score,
                context_impact
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', (
            conversation.timestamp,
            conversation.user_input,
            conversation.claude_response,
            conversation.conversation_id,
            conversation.session_id,
            json.dumps(conversation.tools_used),
            json.dumps(conversation.files_mentioned),
            int(conversation.code_generated),
            json.dumps(conversation.insights_extracted),
            json.dumps(conversation.decisions_made),
            json.dumps(conversation.next_actions),
            conversation.conversation_type,
            conversation.importance_score,
            conversation.context_impact
        ))
        
        conn.commit()
        conn.close()
    
    def start_file_monitoring(self):
        """Start monitoring file system for Claude-generated changes"""
        
        if not self.is_monitoring:
            self.observer = Observer()
            self.observer.schedule(self.file_monitor, str(self.project_root), recursive=True)
            self.observer.start()
            self.is_monitoring = True
            print("ðŸ‘ï¸  File monitoring started")
    
    def stop_file_monitoring(self):
        """Stop file monitoring"""
        
        if self.is_monitoring and hasattr(self, 'observer'):
            self.observer.stop()
            self.observer.join()
            self.is_monitoring = False
            print("ðŸ‘ï¸  File monitoring stopped")
    
    def process_claude_file_change(self, file_path: str):
        """Process a Claude-generated file change"""
        
        file_change = {
            "timestamp": datetime.now().isoformat(),
            "file_path": file_path,
            "change_type": "claude_generated",
            "session_id": self.current_session_id,
            "impact_level": "medium"
        }
        
        # Store in database
        conn = sqlite3.connect(self.claude_conversations_db)
        cursor = conn.cursor()
        cursor.execute('''
            INSERT INTO file_changes (timestamp, file_path, change_type, session_id, impact_level)
            VALUES (?, ?, ?, ?, ?)
        ''', (file_change["timestamp"], file_change["file_path"], file_change["change_type"], 
              file_change["session_id"], file_change["impact_level"]))
        conn.commit()
        conn.close()
        
        print(f"ðŸ“ Claude file change detected: {Path(file_path).name}")
    
    def end_claude_session(self, summary: str = None):
        """End Claude session and integrate insights"""
        
        # Get session statistics
        conn = sqlite3.connect(self.claude_conversations_db)
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT COUNT(*), AVG(importance_score), SUM(LENGTH(insights_extracted))
            FROM conversations WHERE session_id = ?
        ''', (self.current_session_id,))
        
        stats = cursor.fetchone()
        total_conversations = stats[0] if stats[0] else 0
        avg_importance = stats[1] if stats[1] else 0
        total_insights = stats[2] if stats[2] else 0
        
        # Update session in database
        cursor.execute('''
            UPDATE sessions 
            SET end_time = ?, total_conversations = ?, status = ?, key_achievements = ?
            WHERE session_id = ?
        ''', (datetime.now().isoformat(), total_conversations, "completed", 
              summary or "Session completed", self.current_session_id))
        
        conn.commit()
        conn.close()
        
        # Stop file monitoring
        self.stop_file_monitoring()
        
        # Integrate with evolution system
        if self.evolution_system:
            self.evolution_system.end_session(f"Claude session: {summary or 'Completed'}")
        
        # Update comprehensive context
        self.update_comprehensive_context()
        
        print(f"ðŸ Claude session ended: {self.current_session_id}")
        print(f"ðŸ“Š Conversations: {total_conversations}, Avg Importance: {avg_importance:.2f}")
        
        return self.current_session_id
    
    def update_comprehensive_context(self):
        """Update comprehensive context with Claude session insights"""
        
        # Get high-importance insights from current session
        conn = sqlite3.connect(self.claude_conversations_db)
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT insights_extracted, decisions_made, next_actions, conversation_type
            FROM conversations 
            WHERE session_id = ? AND importance_score > 0.6
            ORDER BY importance_score DESC
        ''', (self.current_session_id,))
        
        results = cursor.fetchall()
        conn.close()
        
        if not results:
            return
        
        # Compile insights
        all_insights = []
        all_decisions = []
        all_actions = []
        
        for row in results:
            insights = json.loads(row[0]) if row[0] else []
            decisions = json.loads(row[1]) if row[1] else []
            actions = json.loads(row[2]) if row[2] else []
            
            all_insights.extend(insights)
            all_decisions.extend(decisions)
            all_actions.extend(actions)
        
        # Create integration content
        integration_content = f"""
## CLAUDE CODE SESSION INSIGHTS - {self.current_session_id}
**Generated:** {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}

### Key Insights from Claude Conversations:
{chr(10).join(f"- {insight}" for insight in all_insights[:10])}

### Decisions Made:
{chr(10).join(f"- {decision}" for decision in all_decisions[:5])}

### Next Actions Identified:
{chr(10).join(f"- {action}" for action in all_actions[:5])}

### Session Statistics:
- **Total Conversations:** {len(results)}
- **High-Importance Insights:** {len(all_insights)}
- **Strategic Decisions:** {len(all_decisions)}
- **Action Items:** {len(all_actions)}
"""
        
        # Append to comprehensive context
        comprehensive_context = self.project_root / "COMPREHENSIVE_CONTEXT.md"
        if comprehensive_context.exists():
            with open(comprehensive_context, 'r') as f:
                current_content = f.read()
            
            insertion_point = "# [END OF COMPREHENSIVE CONTEXT] - Begin user prompt below:"
            if insertion_point in current_content:
                new_content = current_content.replace(
                    insertion_point,
                    f"{integration_content}\n\n{insertion_point}"
                )
                
                with open(comprehensive_context, 'w') as f:
                    f.write(new_content)
                
                print("ðŸ“ Comprehensive context updated with Claude session insights")
    
    def search_claude_conversations(self, query: str, session_id: str = None) -> List[Dict[str, Any]]:
        """Search Claude conversations"""
        
        conn = sqlite3.connect(self.claude_conversations_db)
        cursor = conn.cursor()
        
        if session_id:
            cursor.execute('''
                SELECT * FROM conversations 
                WHERE session_id = ? AND (
                    user_input LIKE ? OR 
                    claude_response LIKE ? OR 
                    insights_extracted LIKE ?
                )
                ORDER BY importance_score DESC
            ''', (session_id, f"%{query}%", f"%{query}%", f"%{query}%"))
        else:
            cursor.execute('''
                SELECT * FROM conversations 
                WHERE user_input LIKE ? OR 
                      claude_response LIKE ? OR 
                      insights_extracted LIKE ?
                ORDER BY importance_score DESC
            ''', (f"%{query}%", f"%{query}%", f"%{query}%"))
        
        results = cursor.fetchall()
        conn.close()
        
        return [dict(zip([col[0] for col in cursor.description], row)) for row in results]
    
    def get_claude_session_summary(self, session_id: str = None) -> Dict[str, Any]:
        """Get summary of Claude session"""
        
        if session_id is None:
            session_id = self.current_session_id
        
        conn = sqlite3.connect(self.claude_conversations_db)
        cursor = conn.cursor()
        
        # Get session info
        cursor.execute('SELECT * FROM sessions WHERE session_id = ?', (session_id,))
        session_info = cursor.fetchone()
        
        # Get conversation stats
        cursor.execute('''
            SELECT 
                COUNT(*) as total_conversations,
                AVG(importance_score) as avg_importance,
                COUNT(CASE WHEN code_generated = 1 THEN 1 END) as code_conversations,
                COUNT(CASE WHEN context_impact = 'critical' THEN 1 END) as critical_conversations
            FROM conversations 
            WHERE session_id = ?
        ''', (session_id,))
        
        stats = cursor.fetchone()
        conn.close()
        
        return {
            "session_id": session_id,
            "session_info": dict(zip([col[0] for col in cursor.description], session_info)) if session_info else None,
            "statistics": dict(zip([col[0] for col in cursor.description], stats)) if stats else None
        }


def main():
    """CLI interface for Claude Code integration"""
    import argparse
    
    parser = argparse.ArgumentParser(description="Claude Code Integration System")
    parser.add_argument("--start", type=str, help="Start Claude session with purpose")
    parser.add_argument("--capture", nargs=2, metavar=('USER', 'CLAUDE'), help="Capture conversation")
    parser.add_argument("--end", type=str, help="End Claude session with summary")
    parser.add_argument("--search", type=str, help="Search conversations")
    parser.add_argument("--summary", type=str, help="Get session summary")
    parser.add_argument("--monitor", action="store_true", help="Start file monitoring")
    
    args = parser.parse_args()
    
    ccis = ClaudeCodeIntegrationSystem()
    
    if args.start:
        ccis.start_claude_session(args.start)
    elif args.capture:
        ccis.capture_claude_conversation(args.capture[0], args.capture[1])
    elif args.end:
        ccis.end_claude_session(args.end)
    elif args.search:
        results = ccis.search_claude_conversations(args.search)
        print(f"Found {len(results)} conversations:")
        for result in results[:5]:
            print(f"- {result['conversation_id']}: {result['user_input'][:50]}...")
    elif args.summary:
        summary = ccis.get_claude_session_summary(args.summary if args.summary != "current" else None)
        print(json.dumps(summary, indent=2))
    elif args.monitor:
        ccis.start_file_monitoring()
        print("Monitoring started. Press Ctrl+C to stop.")
        try:
            while True:
                time.sleep(1)
        except KeyboardInterrupt:
            ccis.stop_file_monitoring()
    else:
        ccis.start_claude_session("Interactive session")


if __name__ == "__main__":
    main()